#!/usr/bin/env python3
from __future__ import annotations

import shutil
from pathlib import Path

REPO_ROOT = Path(".").resolve()

SRC_DIR = REPO_ROOT / "src"
OUT_DIR = REPO_ROOT / "public"
PARTIALS_DIR = REPO_ROOT / "partials"

# Keep these folders in public if they are produced by other builders (like build_blog.py)
PRESERVE_IN_PUBLIC = {
    "blogs",       # blog pages
    "search.json", # if build_blog.py writes it at /public/search.json
    "templates",   # if build_blog.py writes templates under /public/templates
}

HEADER_TOKEN = "<!--HEADER-->"
FOOTER_TOKEN = "<!--FOOTER-->"

def read_text(p: Path) -> str:
    return p.read_text(encoding="utf-8", errors="ignore")

def write_text(p: Path, s: str) -> None:
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(s, encoding="utf-8")

def load_partial(name: str) -> str:
    p = PARTIALS_DIR / name
    if not p.exists():
        return ""
    return read_text(p)

def inject_partials(html: str, header: str, footer: str) -> str:
    if HEADER_TOKEN in html:
        html = html.replace(HEADER_TOKEN, header)
    if FOOTER_TOKEN in html:
        html = html.replace(FOOTER_TOKEN, footer)
    return html

def safe_clean_public(out_dir: Path) -> None:
    """
    Clean /public except preserved paths. This prevents stale files,
    but keeps blog output if build_blog.py is generating it.
    """
    out_dir.mkdir(parents=True, exist_ok=True)

    for item in out_dir.iterdir():
        name = item.name
        if name in PRESERVE_IN_PUBLIC:
            continue
        # If preserving a file (like search.json), skip it
        if name in PRESERVE_IN_PUBLIC and item.is_file():
            continue

        if item.is_dir():
            shutil.rmtree(item)
        else:
            item.unlink()

def copy_non_html(src_root: Path, out_root: Path) -> int:
    """
    Copy everything from src/ to public/ EXCEPT .html files (handled separately).
    Returns count copied.
    """
    count = 0
    for src_path in src_root.rglob("*"):
        if src_path.is_dir():
            continue
        if src_path.suffix.lower() == ".html":
            continue

        rel = src_path.relative_to(src_root)
        dst_path = out_root / rel
        dst_path.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy2(src_path, dst_path)
        count += 1
    return count

def build_html(src_root: Path, out_root: Path, header: str, footer: str) -> int:
    """
    Render HTML files from src/ into public/ with header/footer injection.
    Returns count rendered.
    """
    count = 0
    for src_html in src_root.rglob("*.html"):
        rel = src_html.relative_to(src_root)
        dst_html = out_root / rel

        html = read_text(src_html)
        html2 = inject_partials(html, header, footer)

        write_text(dst_html, html2)
        count += 1
    return count

def main() -> None:
    if not SRC_DIR.exists():
        raise SystemExit(f"ERROR: {SRC_DIR} does not exist. Move your site files into src/ first.")

    header = load_partial("header.html")
    footer = load_partial("footer.html")

    # Clean public/ but keep blog outputs generated by build_blog.py
    safe_clean_public(OUT_DIR)

    copied = copy_non_html(SRC_DIR, OUT_DIR)
    rendered = build_html(SRC_DIR, OUT_DIR, header, footer)

    print(f"Built site:")
    print(f"- HTML rendered: {rendered}")
    print(f"- Non-HTML assets copied: {copied}")
    print(f"Output: {OUT_DIR}")

if __name__ == "__main__":
    main()

